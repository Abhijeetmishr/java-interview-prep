package DSA.Backtracking.subsets;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Given a word, write a function to generate all of its unique generalized abbreviations.

A generalized abbreviation of a word can be generated by replacing each substring of the word with the count of characters in the substring. Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count of characters, we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

Note: All contiguous characters should be considered one substring, e.g., we can’t take “a” and “b” as substrings to get “11”; since “a” and “b” are contiguous, we should consider them together as one substring to get an abbreviation “2”.

Example 1:

Input: "BAT"
Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"
Example 2:

Input: "code"
Output: "code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4"

 */


// Approach 1 using BFS

// public class UniqueGeneralizedAbbreviation {
//     static class AbbreviatedWord {
//           StringBuilder str;
//           int start;
//           int count;
        
//           public AbbreviatedWord(StringBuilder str, int start, int count) {
//             this.str = str;
//             this.start = start;
//             this.count = count;
//           }
//     }
//     public static List<String> generateGeneralizedAbbreviation(String word) {
//         int wordLen = word.length();
//         List<String> result = new ArrayList<String>();
//         Queue<AbbreviatedWord> queue = new LinkedList<>();
//         queue.add(new AbbreviatedWord(new StringBuilder(), 0, 0));
//         while (!queue.isEmpty()) {
//             AbbreviatedWord abWord = queue.poll();
//             if (abWord.start == wordLen) {
//                 if (abWord.count != 0)
//                 abWord.str.append(abWord.count);
//                 result.add(abWord.str.toString());
//             } else {
//                 // continue abbreviating by incrementing the current abbreviation count
//                 queue.add(new AbbreviatedWord(new StringBuilder(abWord.str), 
//                                                 abWord.start + 1, abWord.count + 1));

//                 // restart abbreviating, append the count and the current character to the string
//                 if (abWord.count != 0)
//                 abWord.str.append(abWord.count);
//                 queue.add(
//                     new AbbreviatedWord(new StringBuilder(
//                             abWord.str).append(word.charAt(abWord.start)), abWord.start + 1, 0));
//             }
//         }
//         return result;
//   }

//   public static void main(String[] args) {
//     List<String> result = generateGeneralizedAbbreviation("BAT");
//     System.out.println("Generalized abbreviation are: " + result);

//     result = generateGeneralizedAbbreviation("code");
//     System.out.println("Generalized abbreviation are: " + result);
//   }
// }


// Approach 2 using DFS Backtracking

public class UniqueGeneralizedAbbreviation {
    public List<String> generateGeneralizedAbbreviation(String word) {
        List<String> result = new ArrayList<>();
        backtrack(word, 0, new StringBuilder(), 0, result);
        return result;
    }

    private void backtrack(String word, int index, StringBuilder current, int count, List<String> result) {
        if (index == word.length()) {
            if (count > 0) current.append(count);
            result.add(current.toString());
            if (count > 0)
                current.setLength(current.length() - String.valueOf(count).length()); // backtrack
            return;
        }

        // Option 1: abbreviate this char
        backtrack(word, index + 1, current, count + 1, result);

        // Option 2: keep this char
        int len = current.length();
        if (count > 0) current.append(count);
        current.append(word.charAt(index));
        backtrack(word, index + 1, current, 0, result);
        current.setLength(len); // undo changes
    }
}